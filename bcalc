#!/bin/bash
# A calculator in pure-bash.
# I even made a pure-bash lexer for this.
# Not gonna lie I feel pretty accomplished right now.

# Get all args, and split each character by newline.
args="$(echo "$@" | grep -o .)"

# Read each newline-separated character into an array.
read -d '\n' -a args_array <<< "$args"

# Set empty arrays to be appended to later.
n1_array=()
n2_array=()

# Iterate over the argument array.
for i in "${args_array[@]}"; do
    # Check if the operator is set, and append to the n2_array if so.
    if [ -n "$op" ]; then
        if [[ "$i" =~ ^[0-9]+$ ]]; then
            n2_array+=("$i")
        fi
    fi
    # Check if "$i" is a number, and if so...
    if [[ "$i" =~ ^[0-9]+$ ]]; then
        # If "$op" is set, continue and skip appending to n1_array.
        if [ -n "$op" ]; then
            continue
        else
            # Otherwise append the number to the array.
            n1_array+=("$i")
        fi
    fi
    # Check if "$i" is a math operation, and if so, set the "$op" var to it.
    if [ "$i" == "*" ] || [ "$i" == "/" ] || [ "$i" == "+" ] || [ "$i" == "-" ]; then
        op="$i"
    fi
done

# The _pre variables contain all the elements of the respective number arrays.
# Then {n1,n2} are the contents of the _pre variables with the spaces removed.
n1_pre="${n1_array[*]}"
n1="${n1_pre// /}"
n2_pre="${n2_array[*]}"
n2="${n2_pre// /}"

# Case the math operation then do the actual math.
case "$op" in
    "*") echo $(("$n1" * "$n2"));;
    "/") echo $(("$n1" / "$n2"));;
    "+") echo $(("$n1" + "$n2"));;
    "-") echo $(("$n1" - "$n2"));;
    *) echo "Sorry, $op is not a supported operation." && exit 1;;
esac
